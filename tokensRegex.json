[
  {
    "regex": "class",
    "description": "class"
  },
  {
    "regex": "var",
    "description": "declaration"
  },
  {
    "regex": "function",
    "description": "function"
  },
  {
    "regex": "callout",
    "description": "callout"
  },
  {
    "regex": "package",
    "description": "package"
  },
  {
    "regex": "void ",
    "description": "type"
  },
  {
    "regex": "int ",
    "description": "type"
  },
  {
    "regex": "for",
    "description": "for"
  },
  {
    "regex": "if ",
    "description": "if"
  },
  {
    "regex": "break",
    "description": "break"
  },
  {
    "regex": "continue",
    "description": "continue"
  },
  {
    "regex": "boolean ",
    "description": "type"
  },
  {
    "regex": "string ",
    "description": "type"
  },
  {
    "regex": "return ",
    "description": "return"
  },
  {
    "regex": "char ",
    "description": "type"
  },
  {
    "regex": "{",
    "description": "bracket"
  },
  {
    "regex": "}",
    "description": "bracket"
  },
  {
    "regex": "(",
    "description": "lparen"
  },
  {
    "regex": ")",
    "description": "rparen"
  },
  {
    "regex": ";",
    "description": "semicolon"
  },
  {
    "regex": ",",
    "description": "comma"
  },
  {
    "regex": "[",
    "description": "lbracket"
  },
  {
    "regex": "]",
    "description": "rbracket"
  },
  {
    "regex": "Program",
    "description": "identifier"
  },
  {
    "regex": "0x[0-9a-fA-F]+",
    "description": "int_lit"
  },
  {
    "regex": "[0-9]+",
    "description": "int_lit"
  },
  {
    "regex": "[a-zA-Z_][a-zA-Z_1-9]+",
    "description": "identifier"
  },
  {
    "regex": "true",
    "description": "bool_literal"
  },
  {
    "regex": "false",
    "description": "bool_literal"
  },
  {
    "regex": "\"[ -!#-~]+\"",
    "description": "string_literal"
  },
  {
    "regex": "'[ -!#-~]'",
    "description": "char_literal"
  },
  {
    "regex": "//[ -!#-~\r]+\n",
    "description": "comment"
  },
  {
    "regex": "!",
    "description": "not_op"
  },
  {
    "regex": "==",
    "description": "eq_op"
  },
  {
    "regex": "!=",
    "description": "eq_op"
  },
  {
    "regex": "&&",
    "description": "cond_op"
  },
  {
    "regex": "||",
    "description": "cond_op"
  },
  {
    "regex": "=",
    "description": "assign"
  },
  {
    "regex": "+=",
    "description": "assign"
  },
  {
    "regex": "-=",
    "description": "assign"
  },
  {
    "regex": "+",
    "description": "arith_op"
  },
  {
    "regex": "-",
    "description": "arith_op"
  },
  {
    "regex": "*",
    "description": "arith_op"
  },
  {
    "regex": "/",
    "description": "arith_op"
  },
  {
    "regex": "%",
    "description": "arith_op"
  },
  {
    "regex": "<",
    "description": "rel_op"
  }
  ,
  {
    "regex": ">",
    "description": "rel_op"
  }
  ,
  {
    "regex": "<=",
    "description": "rel_op"
  }
  ,
  {
    "regex": ">=",
    "description": "rel_op"
  },
  {
    "regex": " ",
    "description": "whitespace"
  },
  {
    "regex": "\n",
    "description": "whitespace"
  },
  {
    "regex": "\r",
    "description": "whitespace"
  },
  {
    "regex": "\t",
    "description": "whitespace"
  },
  {
    "regex": "\f",
    "description": "whitespace"
  }
]